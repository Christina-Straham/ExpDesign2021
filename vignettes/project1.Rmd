---
title: "Project 1 practical sessions"
author: "Tim Triche"
date: "September 27th, 2021"
output: 
  html_document:
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Project1}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(devtools)
load_all("./")
```

# Installation

Install the ExpDesign2021 package from github.

```{r eval = FALSE, message = FALSE}
#install.packages("remotes")
#install.packages("BiocManager")
#BiocManager::install("VanAndelInstitute/ExpDesign2021", build_vignettes=TRUE)
```

# Introduction

We'll follow [the tidymodels intro](https://www.tidymodels.org/start/models/), 
but we'll concentrate on the data you (plural) have been generating so far. 

To avoid some annoyance, I wrapped the usual read_sheet and gs4_deauth 
rigamarole in a function called `fetchAssignments` or, explicitly, 
ExpDesign2021::fetchAssignments. (If you want to be super clear about where 
a function should come from, package::function(arguments) is the way to go.)
Let's start by loading data from the first few weeks' assignments.

```{r eval=TRUE}

# this package
library(ExpDesign2021)

# grab some data to verify it works 
assignments <- fetchAssignments()
# note that this is equivalent to:
# fetchAssignments() -> assignments 

# verify we got it: 
kable(head(assignments)) # the first few rows
# you can also echo the result of assigning a variable:
# (fetchAssignments() -> assignments) # try it if you like

# rename the columns for brevity in the following code:
columnNames <- colnames(assignments)           # we will re-use this later; 
names(columnNames) <- c("timestamp", "ID",     # these will be the new names
                        "assignment", "start", 
                        "end", "comments")

# what's it look like now? Mostly so we can see what we're doing.
tibble(oldName=columnNames, newName=names(columnNames)) %>% kable

# now make this tidier:
fetchAssignments() %>%                         # get data, then 
  rename(columnNames) %>%                      # rename columns, then 
  select(c("timestamp", "ID", "comments")) %>% # select columns, then 
  head(2) %>%                                  # get the first two lines, then 
  kable                                        # make a table out of them. 
```

FooBarBazQux is the userID I (tim) chose. I'm not a student, so out it goes.
Let's also add a column for time taken, and filter based on that.

```{r eval=TRUE}
library(lubridate)                             # for date handling

fetchAssignments() %>%                         # get data, then 
  rename(columnNames) %>%                      # rename columns, then 
  filter(ID != "FooBarBazQux") %>%             # exclude my entry, then  
  mutate(minutes = end - start) %>%            # add a column `minutes`, then
  filter(minutes > 0) ->                       # drop negative times, then
    assignments                                # put the result in `assignments`

# How many entries remain? 
assignments %>% dim 
# [1] 95  7

```

# Exploration

Let's do a bit of exploratory analysis on the tidied assignment data. 
Unless you are trying to hide data, a beeswarm is usually a good default.
(Tip: statisticians and statistical reviewers *will* pounce on boxplots.)

```{r eval=TRUE}

library(ggplot2)  # ggplot
library(ggforce)  # geom_sina
library(ggthemes) # theme_tufte

# minimalist sinaplot (beeswarm):
assignments %>%                                        # feed data to...
  ggplot(aes(x = ID, y = minutes, color = ID)) +       # a plot with aesthetics
    geom_sina(show.legend = FALSE) +                   # rendered as a sinaplot
    scale_x_discrete(guide = guide_axis(angle = 60)) + # with IDs at 60' angle
    theme_tufte(base_size = 12,                        # tufte theme, 12pt font
                base_family = "sans serif") +          # with sans serif text
    theme(axis.title.x = element_blank()) +            # blank the axis title
    ggtitle("Time spent on assignments by ID")         # add a plot title  

```

Let's do a little bit of modeling on the data. First, let's group assignments.
(It turns out that both the comments and the assignment names can use some work)
Let's see if we can extract some rhyme or reason from the words making up these.
(For more on this topic, you can visit the [tidy text mining book site](https://www.tidytextmining.com/tidytext.html).)

```{r eval=TRUE}

# a quick helper function: 
assignmentType <- function(x) {
  # grepl tests for a pattern and returns TRUE or FALSE  
  # ifelse operates as ifelse(condition, ifTRUE, ifFALSE)
  # here we nest a second ifelse into the first to mop up
  ifelse(grepl("(git|management|studio|lab)", x), 
         "lab", ifelse(grepl("(islr|statistical|modeling)", x), 
                       "ISLRv2", "EDfB"))
}

# now tokenize by type:
library(tidytext)
assignments %>%                                          # feed data to... 
  mutate(assid = tolower(assignment)) %>%                # create a new column
  mutate(comid = tolower(comments)) %>%                  # create a new column
  mutate(atype = assignmentType(assid)) %>%              # group assignments 
  unnest_tokens(input = comments, output = ctext) %>%    # put words in `ctext`
  select(ID, assid, atype, comid, ctext, minutes) ->     # select a few columns 
    assignment_comments                                  # assign the results

# what has this done for us? Let's look:
assignment_comments %>%                   # feed the tokenized data to..
  filter(!is.na(ctext)) %>%               # only look at non-NA comments
  select(assid, atype, ctext, comid) %>%  # only look at a few columns 
  head %>%                                # grab the first few lines and
  kable                                   # make a table out of them 

# what words seem to be particularly common?
assignment_comments %>%               # feed the tokenized data to...
  count(atype, ctext, sort = TRUE) -> # count comment words by atype, assign to
    atype_ctext_counts

# see https://www.tidytextmining.com/tfidf.html for some more ideas here.

```

That's better.  Now let's plot things again.

```{r eval=TRUE}

# a new sinaplot
assignments %>%                                        # feed data to...
  mutate(assid = tolower(assignment)) %>%              # create a new column
  mutate(atype = assignmentType(assid)) %>%            # group assignments 
  ggplot(aes(x = atype, y = minutes, color = ID)) +    # a plot with aesthetics
    geom_sina(maxwidth=0.3, show.legend = FALSE) +     # rendered as a sinaplot
    xlab("Assignment type") +                          # grouped by type
    coord_flip() +                                     # but left-to-right 
    theme_tufte(base_size = 12,                        # tufte theme, 12pt font
                base_family = "sans serif") +          # with sans serif text
    ggtitle("Time spent on assignments by type")         # add a plot title  


```

# Faceting and whatnot

ggplot2 is useful in that it will happily split up plots into facets, among 
other handy features.  Here's one example: 


```{r eval=TRUE}

# facet it 
assignments %>%                                        # feed data to...
  mutate(assid = tolower(assignment)) %>%              # create a new column
  mutate(atype = assignmentType(assid)) %>%            # group assignments 
  ggplot(aes(x = atype, y = minutes, color = ID)) +    # a plot with aesthetics
    geom_boxplot(show.legend = FALSE) +                # with an added boxplot
    geom_point(show.legend = FALSE) +                  # and all the data points
    xlab("Assignment type") +                          # grouped by type
    facet_wrap( ~ ID) +                                # split by ID
    coord_flip() +                                     # but left-to-right 
    theme_minimal()

```


# Mixed models

Mixed models attempt to partition variance into `fixed` and `random` 
components, such as a condition (fixed, mean difference) versus a measurement
group (random differences).  This is handy when running replicates, 
particularly if some are technical and some are biological, but there's also 
the possibility of partially pooling some terms.  For now, let's just intro 
some handlers for these types of models.  (These aren't really handled in 
either EDfMB *or* ISLRv2, but they're incredibly useful in actual practice.) 

```{r eval=FALSE}

library(tidymodels)
library(broom.mixed) 
library(lme4)

# lmer == "linear mixed effects regression"
# kind of an old-school example since parsnip doesn't like mixed models yet
lmm1 <- with(sleepstudy, 
             lmer(Reaction ~ Days + (Days | Subject)))

tidy(lmm1)

# this is fairly traditional 
tidy(lmm1, effects = "fixed")
tidy(lmm1, effects = "fixed", conf.int=TRUE)
tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="profile")

# this isn't
tidy(lmm1, effects = "ran_coefs")
tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
tidy(lmm1, effects = "ran_pars", conf.int=TRUE)

```

So, if you visit [the broom.mixed vignette](https://cran.r-project.org/web/packages/broom.mixed/vignettes/broom_mixed_intro.html), you'll find some code to make
a plot of the estimates for various factors in a *different* regression. First, 
adapt that code to the above sleep study. Next we'll start looking at the 
assignments spreadsheet, plotting the data, and fitting models to that. 


# The assignments spreadsheet

Now we're back to what will eventually become project 1.  How about we plot 
some of the columns of the data?

```{r eval=TRUE}

library(sinaplot)
assignments <- fetchAssignments() # tada 

# rename the columns for brevity 
colnames(assignments) <- c("timestamp", "ID", "assignment", 
                           "start", "end", "comments") 

# add a column for "minutes" 
library(lubridate)
assignments %>% mutate(minutes = as.numeric(end - start)) -> assignments

# drop the first two rows
assignments <- assignments[3:nrow(assignments), ] 
assignments$ID <- factor(assignments$ID)

# plot the minutes taken grouped by ID, not super tidy 
with(subset(assignments, minutes > 0), 
     sinaplot(minutes, ID, col=2:7, pch=20))

# only look at assignments which have > 1 entry
assignments$assignment %>% table() %>% sort() %>% tail(9) %>% names() -> ok

# plot the minutes taken grouped by assignment
with(subset(assignments, assignment %in% ok & minutes > 0), 
     sinaplot(minutes, assignment, col=2:7, pch=20))


```

